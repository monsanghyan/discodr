import discord
from discord import app_commands
from dotenv import load_dotenv
from discord.ext import commands, tasks
import datetime
import os
import requests
from discord.ui import View, Select, Button
import asyncio
from censor import censorship

# í† í°
# TOKEN = os.getenv("token")

'''
- ìˆ˜ì—… ë“±ë¡í•œ ì‚¬ëŒë“¤í•œí…Œë§Œ ë³´ì´ëŠ” ë©”ì„¸ì§€
- ìˆ˜ì—… ìë™ ë“±ë¡ ê¸°ëŠ¥
- í•™ìƒ ì´ë¦„ ê¸°ì¤€ìœ¼ë¡œ ê°•ì˜, ë°˜ ì¶”ê°€
- 'Roles': ì´ë¦„, íŒŒì´ì¬ ì˜¤ì „ë°˜, ë“±ë“±ë“±
- ì¶œê²° ê´€ë¦¬
- í•™ìƒ, ê°•ì‚¬ ê¸°ëŠ¥ êµ¬ë¶„ 
- ê°•ì˜ ì‹œì‘, ë, ì‰¬ëŠ” ì‹œê°„ íƒ€ì´ë¨¸
- ë°±ì¤€, í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ í‘¼ ë¬¸ì œ ê°œìˆ˜ ì¶œë ¥
- ê°•í‡´, ê²½ê³  ë¶€ì—¬
- ì§€ê°ì‹œ ë©˜ì…˜
'''

lecture = {}
lecture_attendance = {}
students = {}
teachers = {}
warning_stack = {}
classes = {}
now = datetime.datetime.now()
dt = datetime.datetime.strptime(str(now), "%Y-%m-%d %H:%M:%S.%f")
formatted_dt = dt.strftime("%Y-%m-%d, %H:%M")

teachers["Teacher1"] = 'ì² ìˆ˜ìŒ¤'
teachers["Teacher2"] = 'ì˜í¬ìŒ¤'
teachers["Teacher3"] = 'ë¯¼ìˆ˜ìŒ¤'

students["student1"] = "í™ê¸¸ë™"
students["student2"] = "ê¹€ì² ìˆ˜"
students["student3"] = "ì´ì˜í¬"

lecture_attendance['rlawhtpq'] = {'present': 1, 'absent': 2, 'late': 3}

load_dotenv()

intents = discord.Intents.all()
bot = commands.Bot(command_prefix='/', intents=intents)

# .env íŒŒì¼ ë¡œë“œ
load_dotenv()

# ë³€ìˆ˜ ëª©ë¡(ìˆ˜ì¹˜ ì¡°ì ˆì„ ìœ„í•œ, í˜¹ì€ ì „ì—­ì—ì„œ ì‚¬ìš©ë˜ì–´ì•¼ í•˜ëŠ” ë³€ìˆ˜)
bandict = {}  # ë°´ë‹¹í•œ ë¦¬ìŠ¤íŠ¸ {ë°´ë‹¹í•œ ì‚¬ìš©ì:[í‰íŒ, ë°´ ì‹œê°„, ë°´ íšŸìˆ˜]
ban_standard = 50  # ë©”ì„¸ì§€ë¥¼ ê²€ì—´í•  ê¸°ì¤€
ban_time = 30  # ê¸°ë³¸ ì±„íŒ… ê²€ì—´ ì‹œê°„(ë¶„ë‹¨ìœ„)
reputation_standard = 20  # ê¸°ë³¸ í‰íŒ ì ìˆ˜
reputation_regeneration = 30  # í‰íŒ íšŒë³µ ì†ë„(ë¶„ë‹¨ìœ„)


class MyBot(discord.Client):
    def __init__(self):
        super().__init__(intents=discord.Intents.all())
        self.tree = app_commands.CommandTree(self)  # ìŠ¬ë˜ì‹œ ëª…ë ¹ì–´ ë“±ë¡ìš©

    # ì‹¤í–‰í–ˆì„ë•Œ ëª…ë ¹ì–´ë¥¼ Discordì— ë™ê¸°í™”
    async def on_ready(self):
        print(f"Logged in as {self.user}")
        await self.tree.sync()
        print("Slash commands have been synced.")

    # ë§¤ìƒˆì§€ë¥¼ ë°›ì„ë•Œë§ˆë‹¤ ì‹¤í–‰
    async def on_message(self, message):
        global bandict

        # ì¶”ê°€ë¡œ í•„ìš”í•œ ë³€ìˆ˜ ëª©ë¡
        writer = message.author  # ë§¤ì„¸ì§€ ì‘ì„±ì
        toxic = int(censorship(message.content)*100)  # ë§¤ì„¸ì§€ì˜ ìœ„í—˜ ì •ë„

        # ë´‡ ìì‹ ì´ ë³´ë‚¸ ë©”ì‹œì§€ëŠ” ë¬´ì‹œ
        if writer == self.user:
            return

        if isinstance(message.channel, discord.DMChannel):
            # DMì—ì„œëŠ” ë©”ì‹œì§€ ì‚­ì œê°€ ë¶ˆê°€ëŠ¥í•˜ë¯€ë¡œ ì‹¤í–‰ ì¤‘ì§€
            return

        # í‰íŒì´ ê¹ì¸ì „ì ì´ ìˆê³  ë°´ë‹¹í•œ ìƒíƒœë¼ë©´ ì±„íŒ… ê¸ˆì§€
        if writer in bandict and bandict[writer][0] > reputation_standard:
            await message.delete()
            await writer.send(f"âŒì±„íŒ…ì´ ê¸ˆì§€ë˜ì—ˆìŠµë‹ˆë‹¤.")
            return

        # ë©”ì‹œì§€ ë‚´ìš© ì¶œë ¥
        print(f"ì±„íŒ… ê°ì§€: {writer}: {message.content}")

        # ê²€ì—´
        print(toxic)
        if toxic >= ban_standard:
            await message.delete()

            # í‰íŒ ì¡°ì •
            if writer in bandict:
                bandict[writer][0] += toxic//10
            else:
                bandict[writer] = [toxic//10]

            # ê²€ì—´ ë§¤ì„¸ì§€ ì¶œë ¥
            await message.channel.send(f"ğŸš«ë¶€ì ì ˆí•œ í‘œí˜„ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.")
            await message.channel.send(f"í˜„ì¬ í‰íŒ {reputation_standard - bandict[writer][0]}ì…ë‹ˆë‹¤.")
            if not í‰íŒíšŒë³µ.is_running():  # ì‘ì—…ì´ ì‹¤í–‰ ì¤‘ì´ ì•„ë‹Œ ê²½ìš° ì‹œì‘
                í‰íŒíšŒë³µ.start()

            # ë§Œì¼ í‰íŒì´ 0ë˜ëŠ” ìŒìˆ˜ë¼ë©´ ë°´
            if reputation_standard - bandict[writer][0] <= 0:
                await message.channel.send(f"â›”{writer}ë‹˜ ì±„íŒ…ì´ 30ë¶„ë™ì•ˆ ê¸ˆì§€ë˜ì—ˆìŠµë‹ˆë‹¤.")

                # ë°´ ì‹œê°„ ë° íšŸìˆ˜ ì¶”ê°€
                # ì „ì ì´ ìˆë‹¤ë©´ (ë°´ë‹¹í•œ íšŸìˆ˜ * 30ë¶„)ë§Œí¼ ë°´
                if len(bandict[writer]) > 1:
                    bandict[writer][2] += 1
                    bandict[writer][1] += ban_time*bandict[writer][2]

                # ë°´ë‹¹í•œ ì ì´ ì—†ë‹¤ë©´ 30ë¶„ë§Œ ë°´
                else:
                    bandict[writer].append(ban_time)
                    bandict[writer].append(1)

                # ë°´ íƒ€ì´ë¨¸ ê°€ë™
                if not ë°˜ë³µ_ì‘ì—….is_running():  # ì‘ì—…ì´ ì‹¤í–‰ ì¤‘ì´ ì•„ë‹Œ ê²½ìš° ì‹œì‘
                    ë°˜ë³µ_ì‘ì—….start()


# ë´‡ ê°ì²´ ìƒì„±
client = MyBot()

"""ëª…ë ¹ì–´ ëª¨ìŒ"""


# í‰íŒ í™•ì¸í•˜ëŠ” ëª…ë ¹ì–´
@client.tree.command(name="ë‚´í‰íŒ")
async def reputation(clients: discord.Interaction):
    # ìƒ‰ê¹” ë‚˜ëˆŒ ê¸°ì¤€
    color_st = reputation_standard/5

    # ìœ ì €ê°€ ê²€ì—´ëœì ì´ ìˆë‹¤ë©´ ì ìˆ˜ ì¸¡ì • í›„ í‰íŒ ëŒë ¤ì£¼ê¸°
    if clients.user in bandict:
        score = reputation_standard - bandict[clients.user][0]

        # ë°´ ë‹¹í•œ ìƒíƒœë¼ë©´ í•´ì œ ì‹œê°„ë„ ë³´ì—¬ì£¼ê¸°
        if score <= 0:
            await clients.response.send_message(f"â˜ ï¸{reputation_standard}ì  ë§Œì ì— {score}ì  ì…ë‹ˆë‹¤." + "\n" +
                                                f"{bandict[clients.user][1]}ë¶„ í›„ ë‹¤ì‹œ ì±„íŒ…ì„ ì…ë ¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
                                                ephemeral=True)

        # ë°´ ë‹¹í•œ ìƒíƒœê°€ ì•„ë‹ˆë¼ë©´ í˜„ì œ í‰íŒ ê³„ì‚°í•´ì„œ ë³´ì—¬ì£¼ê¸°
        else:
            if 0 < score <= color_st:
                color = "ğŸ”´"
            elif color_st < score <= color_st*2:
                color = "ğŸŸ "
            elif color_st*2 < score <= color_st*3:
                color = "ğŸŸ¡"
            elif color_st*3 < score <= color_st*4:
                color = "ğŸŸ¢"
            elif color_st*4 < score < color_st*5:
                color = "ğŸ”µ"
            elif color_st*5 == score:
                color = "âšª"
            print(color, score)
            await clients.response.send_message(f"{color}{reputation_standard}ì  ë§Œì ì— {score}ì  ì…ë‹ˆë‹¤", ephemeral=True)

    # ì±„íŒ…ì´ ê²€ì—´ëœì ì´ ì—†ë‹¤ë©´ ë§Œì 
    else:
        await clients.response.send_message(f"âšª{reputation_standard}ì  ë§Œì ì— {reputation_standard}ì  ì…ë‹ˆë‹¤. ",
                                            ephemeral=True)


# ë°´ í•´ì¬ì‹œê°„ì— ëŒ€í•œ ì •ë³´ ì œê³µ
@client.tree.command(name="í•´ì¬ì‹œê°„")
async def time(it):
    # ì‹œê°„, ë¶„ ê°€ì ¸ì˜¤ê¸°
    hour, minute = map(int, datetime.datetime.now().strftime("%H %M").split())

    # ë°´ë‹¹í•˜ì—¬ ë°´ì‹œê°„ì´ 0ì´ ì•„ë‹Œê²½ìš° ëª‡ì‹œì— ì—´ë¦¬ëŠ”ì§€ ê³„ì‚°
    if it.user in bandict and bandict[it.user][1] != 0:
        await it.response.send_message(
            f"â±ï¸{(hour + (minute + bandict[it.user][1])//60)%12}:{(minute + bandict[it.user][1])%60}ì— í•´ì¬ë©ë‹ˆë‹¤.",
            ephemeral=True)

    # ë°´ë‹¹í•˜ì§€ ì•Šì•˜ë‹¤ë©´ ì‹œê°„ ì•Œë¦¼ ì—†ìŒ
    else:
        await it.response.send_message("ë§¤ì„¸ì§€ë°´ì„ ë‹¹í•˜ì§€ ì•Šìœ¼ì…¨ìŠµë‹ˆë‹¤.")


# ë°´ì‹œê°„ í™•ì¸ ë° í•´ì œ
@tasks.loop(minutes=1)
async def ë°˜ë³µ_ì‘ì—…():
    global bandict

    # ë°´ë‹¹í•œ ì‚¬ëŒì´ ìˆë‚˜ í™•ì¸
    swith = True

    # ì±„ë„ í™•ì¸
    channel = client.get_channel(1324237420798939156)  # ì—¬ê¸°ì— ë””ìŠ¤ì½”ë“œ ì±„ë„ IDë¥¼ ì…ë ¥
    if channel:

        # 1ë¶„ë§ˆë‹¤ ë°´ ì‹œê°„ 1ì”© ê°ì†Œ
        for i in bandict.keys():
            if bandict[i][1] > 0:
                swith = False
            bandict[i][1] -= 1
            if bandict[i][1] == 0:
                bandict[i][0] = 0
                await channel.send(f"ğŸ”“{i}ë‹˜ ì±„íŒ… ê¸ˆì§€ê°€ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.")

        # ë”ì´ìƒ ë°´ë‹¹í•œ ì‚¬ëŒì´ ì—†ë‹¤ë©´ ì¤‘ì§€
        if swith:
            ë°˜ë³µ_ì‘ì—….stop()


# í‰íŒ íšŒë³µ
@tasks.loop(minutes=reputation_regeneration)
async def í‰íŒíšŒë³µ():
    global bandict

    # í‰íŒì´ íšŒë³µ ê°€ëŠ¥í•œ ì‚¬ëŒì´ ì—†ëŠ” ê²½ìš° í™•ì¸
    swith = True

    for i in bandict.keys():

        # ë°´ë‹¹í•œ ìƒíƒœì´ê±°ë‚˜ í‰íŒì´ ë§Œì ì¸ ìƒíƒœì—ì„œëŠ” í‰íŒ íšŒë³µ ë¶ˆê°€ëŠ¥
        if 0 < bandict[i][0] < 20:
            bandict[i][0] -= 1
            swith = False

    # ë§Œì¼ ì—†ë‹¤ë©´ ì‹¤í–‰ ì¤‘ì§€
    if swith:
        í‰íŒíšŒë³µ.stop()


@bot.event
async def on_ready():
    print(f'{bot.user} ë””ìŠ¤ì½”ë“œ ì¤€ë¹„ ì™„ë£Œ!')
    print('-'*35)


# /í•™ìƒë“±ë¡
@client.tree.command(name="í•™ìƒë“±ë¡", description="student register")
async def student_register(ctx: discord.Interaction, username: str, nickname: str):
    guild = ctx.guild
    member = discord.utils.get(guild.members, name=username)

    if not member:
        await ctx.response.send_message("ì´ ìœ ì €ëŠ” ì„œë²„ì— ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
        return

    elif member.bot:
        await ctx.response.send_message("í•´ë‹¹ ìœ ì €ëŠ” ë´‡ì…ë‹ˆë‹¤.")

    elif username not in students:
        await ctx.response.send_message("ì•„ì§ í•™ìƒ ë“±ë¡ì„ ì•ˆí•˜ì…¨ìŠµë‹ˆë‹¤.")

        yes_button = discord.ui.Button(label="Yes", custom_id="yes", style=discord.ButtonStyle.success)
        no_button = discord.ui.Button(label="No", custom_id="no", style=discord.ButtonStyle.danger)

        async def button_callback(interaction: discord.Interaction):
            if interaction.data['custom_id'] == 'yes':
                students[username] = nickname
                student_role = discord.utils.get(guild.roles, name="í•™ìƒ")
                if not student_role:
                    student_role = await guild.create_role(name="í•™ìƒ")

                if student_role:
                    await member.add_roles(student_role)

                await interaction.response.send_message(f"{username}ë‹˜ì„ ì„±ê³µì ìœ¼ë¡œ í•™ìƒìœ¼ë¡œ ë“±ë¡í•˜ì˜€ìŠµë‹ˆë‹¤!")
            elif interaction.data['custom_id'] == 'no':
                await interaction.response.send_message("ì·¨ì†Œ ë˜ì—ˆìŠµë‹ˆë‹¤.")

            await interaction.message.edit(view=None)

        yes_button.callback = button_callback
        no_button.callback = button_callback

        view = discord.ui.View()
        view.add_item(yes_button)
        view.add_item(no_button)

        embed = discord.Embed(
            title="â€ğŸ§‘â€ğŸ“ í•™ìƒì„ ë“±ë¡í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
            description=f"ğŸ†” ì•„ì´ë””: {username}\n ğŸ­ ë³„ëª…: {nickname}",
            color=discord.Colour.blurple()
        )

        embed.set_footer(text=f"{formatted_dt}ì— ì‹¤í–‰ë¨")
        embed.set_author(name=ctx.user.name)

        await ctx.followup.send(embed=embed, view=view)
    else:
        await ctx.response.send_message(f"{username}ë‹˜ì€ ì´ë¯¸ ê³„ì •ì´ ë“±ë¡ë˜ì–´ ìˆìŠµë‹ˆë‹¤.")


# /ê°•ì‚¬ë“±ë¡
@client.tree.command(name="ê°•ì‚¬ë“±ë¡", description="teacher register")
async def teacher_register(ctx: discord.Interaction, username: str, nickname: str):
    guild = ctx.guild
    member = discord.utils.get(guild.members, name=username)

    if not member:
        await ctx.response.send_message("ì´ ìœ ì €ëŠ” ì„œë²„ì— ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")

    elif member.bot:
        await ctx.response.send_message("í•´ë‹¹ ìœ ì €ëŠ” ë´‡ì…ë‹ˆë‹¤.")

    elif username not in students:
        await ctx.response.send_message("ì•„ì§ ê°•ì‚¬ë¥¼ ë“±ë¡ì„ ì•ˆí•˜ì…¨ìŠµë‹ˆë‹¤.")

        yes_button = discord.ui.Button(label="Yes", custom_id="yes", style=discord.ButtonStyle.success)
        no_button = discord.ui.Button(label="No", custom_id="no", style=discord.ButtonStyle.danger)

        async def button_callback(interaction: discord.Interaction):
            if interaction.data['custom_id'] == 'yes':
                teachers[username] = nickname
                teacher_role = discord.utils.get(guild.roles, name="ê°•ì‚¬")
                if not teacher_role:
                    teacher_role = await guild.create_role(name="ê°•ì‚¬")
                if teacher_role:
                    await member.add_roles(teacher_role)
                await interaction.response.send_message(f"{username}ë‹˜ì„ ì„±ê³µì ìœ¼ë¡œ ê°•ì‚¬ë¡œ ë“±ë¡í•˜ì˜€ìŠµë‹ˆë‹¤!")
            elif interaction.data['custom_id'] == 'no':
                await interaction.response.send_message("ì·¨ì†Œ ë˜ì—ˆìŠµë‹ˆë‹¤.")

            await interaction.message.edit(view=None)

        yes_button.callback = button_callback
        no_button.callback = button_callback

        view = discord.ui.View()
        view.add_item(yes_button)
        view.add_item(no_button)

        embed = discord.Embed(
            title="ğŸ‘¨â€ğŸ« ê°•ì‚¬ë¥¼ ë“±ë¡í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
            description=f"ğŸ†” ì•„ì´ë””: {username}\n ğŸ­ ë³„ëª…: {nickname}",
            color=discord.Colour.blurple()
        )

        embed.set_footer(text=f"{formatted_dt}ì— ì‹¤í–‰ë¨")
        embed.set_author(name=ctx.user.name)

        await ctx.send(embed=embed, view=view)
    else:
        await ctx.response.send_message(f"{username}ë‹˜ì€ ì´ë¯¸ ê³„ì •ì´ ë“±ë¡ë˜ì–´ ìˆìŠµë‹ˆë‹¤.")


# /ìˆ˜ì—…ë“±ë¡
@client.tree.command(name="ìˆ˜ì—…ë“±ë¡", description="lecture register (YYYY-MM-DD HH:MM)")
async def register_class(ctx: discord.Interaction, date: str, time: str):
    username = ctx.user.name

    # ìˆ˜ì—… ì‹œê°„ì„ íŒŒì‹±
    time_obj = datetime.datetime.strptime(date + " " + time, "%Y-%m-%d %H:%M")
    if now > time_obj:
        await ctx.response.send_message('ì´ë¯¸ ì§€ë‚œ ë‚ ì§œì…ë‹ˆë‹¤.')

    # ì„œë²„ì˜ ëª¨ë“  í•™ìƒë“¤ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
    student_options = [discord.SelectOption(label=name, value=student) for student, name in students.items()]
    if not student_options:
        await ctx.response.send_message("ë“±ë¡ëœ í•™ìƒì´ ì—†ìŠµë‹ˆë‹¤.")

    # í•™ìƒ ì„ íƒ ë©”ë‰´ ìƒì„± (ë‹¤ì¤‘ ì„ íƒ ê°€ëŠ¥)
    student_select_menu = Select(
        placeholder="í•™ìƒì„ ì„ íƒí•˜ì„¸ìš”",
        options=student_options,
        min_values=1,  # ìµœì†Œ 1ëª… ì„ íƒ
        max_values=len(student_options),  # ìµœëŒ€ í•™ìƒ ìˆ˜
    )

    async def student_select_callback(interaction: discord.Interaction):
        selected_students = student_select_menu.values

        # ì„ ìƒë‹˜ ì„ íƒ ë©”ë‰´ ìƒì„±
        teacher_options = [discord.SelectOption(label=name, value=teacher) for teacher, name in teachers.items()]
        teacher_select_menu = Select(
            placeholder="ê°•ì‚¬ë¥¼ ì„ íƒí•˜ì„¸ìš”",
            options=teacher_options,
            min_values=1,
            max_values=1,
        )

        async def teacher_select_callback(inner_interaction: discord.Interaction):
            selected_teacher = teacher_select_menu.values[0]

            # ìˆ˜ì—… ë“±ë¡ ì²˜ë¦¬
            for student in selected_students:
                if student not in lecture:
                    lecture[student] = [(time_obj, selected_teacher)]
                else:
                    lecture[student].append((time_obj, selected_teacher))

            date_obj = datetime.datetime.strptime(date, "%Y-%m-%d")
            clock_obj = datetime.datetime.strptime(time, "%H:%M")
            formatted_date = date_obj.strftime("%Yë…„ %mì›” %dì¼")
            formatted_clock = clock_obj.strftime("%H:%M")

            formatted_students = []
            for student in selected_students:
                formatted_students.append(students[student])

            embed = discord.Embed(
                title="ìƒˆë¡œìš´ ìˆ˜ì—…ì´ ë“±ë¡ ë˜ì—ˆìŠµë‹ˆë‹¤!",
                description=f"ğŸ‘¨â€ğŸ« ê°•ì‚¬: {teachers[selected_teacher]}\nğŸ§‘â€ğŸ“ í•™ìƒ(ë“¤): {', '.join(formatted_students)}\nğŸ“† ë‚ ì§œ: {formatted_date}\n â° ì‹œê°„: {formatted_clock}",
                color=discord.Colour.green()
            )

            embed.set_footer(text=f"{formatted_dt}ì— ë“±ë¡ë¨")
            embed.set_author(name=username)

            await inner_interaction.response.send_message(embed=embed)

        teacher_select_menu.callback = teacher_select_callback
        teacher_view = View()
        teacher_view.add_item(teacher_select_menu)

        await interaction.response.send_message("ê°•ì‚¬ë¥¼ ì„ íƒí•˜ì„¸ìš”:", view=teacher_view)

    student_select_menu.callback = student_select_callback

    # í•™ìƒ ì„ íƒ ë·° ìƒì„± ë° ì „ì†¡
    student_view = View()
    student_view.add_item(student_select_menu)
    await ctx.response.send_message("í•™ìƒì„ ì„ íƒí•˜ì„¸ìš”:", view=student_view)


# /ì¶œì„
@client.tree.command(name="ì¶œì„", description="attendance check")
async def attendance(ctx: discord.Interaction):
    username = ctx.user.name

    # í•™ìƒì´ ë“±ë¡ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
    if username not in students:
        await ctx.response.send_message(f"{username}ë‹˜ì€ ë“±ë¡ëœ í•™ìƒì´ ì•„ë‹™ë‹ˆë‹¤. ë¨¼ì € ë“±ë¡í•´ì£¼ì„¸ìš”.")
        return

    # í•´ë‹¹ í•™ìƒì˜ ìˆ˜ì—… ì •ë³´ í™•ì¸
    if username not in lecture or not lecture[username]:
        await ctx.response.send_message(f"{username}ë‹˜ì€ ë“±ë¡ëœ ìˆ˜ì—…ì´ ì—†ìŠµë‹ˆë‹¤.")
        return

    # í˜„ì¬ ì‹œê°„ í™•ì¸

    lecture[username].sort()  # ìˆ˜ì—… ì‹œê°„ì„ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
    next_lecture = lecture[username][0]  # ê°€ì¥ ê°€ê¹Œìš´ ìˆ˜ì—… ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    time, teacher = next_lecture  # ìˆ˜ì—… ì‹œê°„ê³¼ ê°•ì‚¬ ì •ë³´ ë¶„ë¦¬

    # ì¶œê²° ê¸°ë¡ ì´ˆê¸°í™”
    if username not in lecture_attendance:
        lecture_attendance[username] = {'present': 0, 'absent': 0, 'late': 0}

    # ìˆ˜ì—… ì‹œê°„ê³¼ í˜„ì¬ ì‹œê°„ ë¹„êµ
    if now >= time:
        if (now - time) >= datetime.timedelta(minutes=5):  # 5ë¶„ ì´ìƒ ì§€ê°
            await ctx.response.send_message(f"{username}ë‹˜ì´ {teacher}ì˜ ìˆ˜ì—…ì— ì§€ê°í•˜ì˜€ìŠµë‹ˆë‹¤. â°")
            lecture_attendance[username]['ì§€ê°'] += 1
        elif 0 <= (now - time) < datetime.timedelta(minutes=5):  # ì •ìƒ ì¶œì„
            await ctx.response.send_message(f"{username}ë‹˜ì´ {teacher}ì˜ ìˆ˜ì—…ì— ì¶œì„í•˜ì˜€ìŠµë‹ˆë‹¤! âœ…")
            lecture_attendance[username]['ì¶œì„'] += 1
        lecture[username].pop(0)  # ì¶œì„ ì™„ë£Œëœ ìˆ˜ì—… ì œê±°
    else:
        # ìˆ˜ì—… ì‹œì‘ ì „
        await ctx.response.send_message(f"ì•„ì§ {teacher}ì˜ ìˆ˜ì—…ì´ ì‹œì‘í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ğŸ˜¢")


# /ìˆ˜ì—…ëª©ë¡
@client.tree.command(name="ìˆ˜ì—…ëª©ë¡", description="lecture list")
async def lecture_list(ctx: discord.Interaction, username: str):
    guild = ctx.guild
    member = guild.get_member_named(username)
    if not member:
        await ctx.response.send_message('ì„œë²„ì— ì¡´ì¬í•˜ì§€ ì•ŠëŠ” í•™ìƒì…ë‹ˆë‹¤.')
    if username not in lecture:
        await ctx.response.send_message('ë“±ë¡ëœ ìˆ˜ì—…ì´ ì—†ìŠµë‹ˆë‹¤.')
    else:
        user_lectures = []
        lecture[username].sort()
        cnt = 0
        for time_obj, teacher in lecture[username]:
            cnt += 1
            formatted_time = time_obj.strftime("%Yë…„ %mì›” %dì¼ %Hì‹œ %Më¶„")
            user_lectures.append(f'{cnt}) ğŸ‘¨â€ğŸ« êµì‚¬ : {teachers[teacher]}, ğŸ“† ìˆ˜ì—… ë‚ ì§œ : {formatted_time}')

        embed = discord.Embed(
            title=f"ğŸ“š {students[username]}ë‹˜ì˜ ìˆ˜ì—… ëª©ë¡",
            description=f'{username}ë‹˜ì˜ ìˆ˜ì—… ëª©ë¡ (ì´ {cnt}ê°œ)\n' + '\n'.join(user_lectures),
            color=discord.Colour.green()
        )

        embed.set_footer(text=f"{formatted_dt}ì— ì‹¤í–‰ë¨")
        embed.set_author(name=username)

        await ctx.response.send_message(embed=embed)


# /ë°˜ë“±ë¡
@client.tree.command(name="ë°˜ë“±ë¡", description="class register")
async def register_class(ctx: discord.Interaction, class_name: str, day: str, time: str):
    await ctx.response.defer(ephemeral=True)

    username = ctx.user.name
    guild = ctx.guild
    weekdays = ["ì›”ìš”ì¼", "í™”ìš”ì¼", "ìˆ˜ìš”ì¼", "ëª©ìš”ì¼", "ê¸ˆìš”ì¼", "í† ìš”ì¼", "ì¼ìš”ì¼"]
    prefixed = ["ì›”", "í™”", "ìˆ˜", "ëª©", "ê¸ˆ", "í† ", "ì¼"]

    if day not in weekdays and day not in prefixed:
        await ctx.followup.send("ì˜ëª»ëœ ìš”ì¼ì…ë‹ˆë‹¤.")
        return
    if class_name in classes:
        await ctx.followup.send("ê°™ì€ ì´ë¦„ìœ¼ë¡œ ë“±ë¡ëœ ë°˜ì´ ìˆìŠµë‹ˆë‹¤.")
        return

    # ì„œë²„ì˜ ëª¨ë“  í•™ìƒë“¤ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
    student_options = [discord.SelectOption(label=name, value=student) for student, name in students.items()]
    if not student_options:
        await ctx.followup.send("ë“±ë¡ëœ í•™ìƒì´ ì—†ìŠµë‹ˆë‹¤.")
        return

    # í•™ìƒ ì„ íƒ ë©”ë‰´ ìƒì„± (ë‹¤ì¤‘ ì„ íƒ ê°€ëŠ¥)
    student_select_menu = Select(
        placeholder="í•™ìƒì„ ì„ íƒí•˜ì„¸ìš”",
        options=student_options,
        min_values=1,  # ìµœì†Œ 1ëª… ì„ íƒ
        max_values=len(student_options),  # ìµœëŒ€ í•™ìƒ ìˆ˜
    )

    async def student_select_callback(interaction: discord.Interaction):
        selected_students = student_select_menu.values

        # ì„ ìƒë‹˜ ì„ íƒ ë©”ë‰´ ìƒì„±
        teacher_options = [discord.SelectOption(label=name, value=teacher) for teacher, name in teachers.items()]
        teacher_select_menu = Select(
            placeholder="ê°•ì‚¬ë¥¼ ì„ íƒí•˜ì„¸ìš”",
            options=teacher_options,
            min_values=1,
            max_values=1,
        )

        async def teacher_select_callback(inner_interaction: discord.Interaction):
            selected_teacher = teacher_select_menu.values[0]
            classes[class_name] = [(selected_students, selected_teacher, day, time)]

            # ìˆ˜ì—… ë“±ë¡ ì²˜ë¦¬
            for student in selected_students:
                member = guild.get_member_named(student)
                if member:
                    class_role = discord.utils.get(guild.roles, name=class_name)
                    if not class_role:
                        class_role = await guild.create_role(name=class_name)
                    await member.add_roles(class_role)

            formatted_students = [students[student] for student in selected_students]

            embed = discord.Embed(
                title=f"{class_name}",
                description=f"ğŸ‘¨â€ğŸ« ê°•ì‚¬: {selected_teacher}\nğŸ§‘â€ğŸ“ í•™ìƒ(ë“¤): {', '.join(formatted_students)}\nğŸ“† ìš”ì¼: {day}\nâ° ì‹œê°„: {time}",
                color=discord.Colour.green()
            )

            embed.set_footer(text=f"{formatted_dt}ì— ì‹¤í–‰ë¨")
            embed.set_author(name=username)

            await inner_interaction.response.send_message(embed=embed)  # ì—¬ê¸°ì—ì„œ ì‘ë‹µ ì²˜ë¦¬

        teacher_select_menu.callback = teacher_select_callback
        teacher_view = View()
        teacher_view.add_item(teacher_select_menu)

        await interaction.response.send_message("ê°•ì‚¬ë¥¼ ì„ íƒí•˜ì„¸ìš”:", view=teacher_view)

    student_select_menu.callback = student_select_callback

    # í•™ìƒ ì„ íƒ ë·° ìƒì„± ë° ì „ì†¡
    student_view = View()
    student_view.add_item(student_select_menu)
    await ctx.followup.send("í•™ìƒ(ë“¤)ì„ ì„ íƒí•˜ì„¸ìš”:", view=student_view)


@client.tree.command(name="ìŠ¤í†±ì›Œì¹˜", description="stopwatch")
async def stopwatch(ctx: discord.Interaction, hour: int = 0, min: int = 0, sec: int = 0):
    guild = ctx.guild
    username = ctx.user.name
    um = discord.utils.get(guild.members, name=username)
    if username in students:
        nick = students[username]
    elif username in teachers:
        nick = teachers[username]
    else:
        await ctx.response.send_message('ê³„ì •ì´ ë“±ë¡ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë¨¼ì € ë“±ë¡í•´ì£¼ì„¸ìš”.')
        return

    if hour + min + sec == 0:
        await ctx.response.send_message('ìŠ¤í†±ì›Œì¹˜ì˜ ìµœì†Œì‹œê°„ì€ 1ì´ˆì…ë‹ˆë‹¤.')
        return

    members = [member for member in ctx.guild.members if not member.bot]  # ë´‡ ì œì™¸
    options = [
        discord.SelectOption(label=member.display_name, value=str(member.id))
        for member in members
    ]

    class UserSelect(Select):
        def __init__(self):
            super().__init__(
                placeholder="ì•Œë¦¼ì„ ë°›ì„ ì‚¬ëŒì„ ì„ íƒí•˜ì„¸ìš”!",
                min_values=1,  # ìµœì†Œ 1ëª…
                max_values=len(members),  # ìµœëŒ€ ì„ íƒ ê°€ëŠ¥í•œ ì¸ì› ìˆ˜
                options=options
            )

        async def callback(self, interaction: discord.Interaction):
            nonlocal selected_users
            selected_users = [interaction.guild.get_member(int(user_id)) for user_id in self.values]
            await interaction.response.send_message(
                f"ì„ íƒëœ ìœ ì €: {', '.join([user.display_name for user in selected_users])}")
            self.view.stop()

    selected_users = []
    view = View()
    view.add_item(UserSelect())
    print(dir(ctx))
    await ctx.response.send_message("ì•Œë¦¼ì„ ë°›ì„ ì‚¬ëŒì„ ì„ íƒí•˜ì„¸ìš”!", view=view)
    await view.wait()

    if not selected_users:
        await ctx.followup.send("ìµœì†Œ 1ëª…ì˜ ìœ ì €ë¥¼ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤.")
        return

    total_seconds = hour*3600 + min*60 + sec
    mentions = ', '.join([user.mention for user in selected_users])  # ì„ íƒëœ ìœ ì €ë“¤ì˜ ë©˜ì…˜
    embed = discord.Embed(
        title=f"{nick}ë‹˜ì˜ ì•Œë¦¼",
        description=f"â° ì‹œê°„: {hour}ì‹œê°„ {min}ë¶„ {sec}ì´ˆ",
        color=discord.Colour.red()
    )

    embed.set_footer(text=f"{formatted_dt}ì— ì„¤ì •ë¨")
    embed.set_author(name=', '.join([user.display_name for user in selected_users]))

    await ctx.followup.send(embed=embed)

    async def countdown():
        await asyncio.sleep(total_seconds)
        await ctx.followup.send(f'{mentions} íƒ€ì´ë¨¸ê°€ ëë‚¬ìŠµë‹ˆë‹¤!')

    asyncio.create_task(countdown())


@client.tree.command(name="ì¶œì„í‘œ", description="attendance status")
async def attendance_status(ctx: discord.Interaction, username: str):
    print(lecture_attendance, 'start def')
    if username not in lecture_attendance:
        await ctx.response.send_message('ì¶œì„ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.')
        return
    if username not in students and username not in teachers:
        await ctx.response.send_message('ì˜ëª»ëœ ìœ ì €ì…ë‹ˆë‹¤.')
        return

    # lecture_attendance[username] = {'ì¶œì„': 0, 'ê²°ì„': 0, 'ì§€ê°': 0}
    k = lecture_attendance[username]
    present = k['present']
    late = k['late']
    absent = k['absent']

    embed = discord.Embed(
        title=f"{students[username]}ë‹˜ì˜ ì¶œì„í‘œ",
        description=f"âœ… ì¶œì„: {present}\nâŒ ê²°ì„: {absent}\nâŒ› ì§€ê°: {late}",
        color=discord.Colour.blurple()
    )
    embed.set_footer(text=f"{formatted_dt} ê¸°ì¤€")
    embed.set_author(name=username)
    print(lecture_attendance,1)
    await ctx.response.send_message(embed=embed)



print(now)
print(lecture_attendance, 'start code')
client.run()
